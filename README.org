#+title: A Virtual Machine (AVM)
#+author: Aryadev Chavali
#+date: 2023-10-15

An exercise in making a virtual machine in C11 with both a stack and
registers.

This repository contains both a shared library ([[file:lib/][lib]]) to
(de)serialise bytecode and a program ([[file:vm/][vm]]) to execute
said bytecode.

* How to build
Requires =GNU make= and a compliant C11 compiler.  Look
[[file:Makefile::CC=gcc][here]] to change the compiler used.

To build a release version simply run ~make all~.  To build a debug
version run ~make all RELEASE=0 VERBOSE=2~ which has most runtime logs
on.  This will build:
+ [[file:lib/][instruction bytecode system]] which provides a shared
  library for serialising and deserialising bytecode
+ [[file:vm/][VM executable]] to execute bytecode
* Targeting the virtual machine
The general idea is to construct a ~prog_t~ structure, which consists
of:
1) A program header with some essential metadata (start address,
   count, etc)
2) An array of type ~inst_t~, an ordered sequence of instructions for
   execution

This structure can be executed in two ways depending on your
requirements.
** Compilation then execution
Use ~prog_write_bytecode~ with a ~prog_t~ structure and a sufficiently
large buffer of bytes, populating the buffer with the corresponding
bytecode.  This buffer is written to some file, the file can then be
executed by the =avm= executable.

This method defers the problem of execution to me, the distributor of
avm, which reduces the complexity of your program to just the process
of generating bytecode.
** Immediate execution
Notice how the previous method serialises the ~prog_t~ into bytecode,
then executes that bytecode via the =avm= executable, which
deserialises the bytecode back into a ~prog_t~.  Furthermore, the
specs of the virtual machine (stack/register/heap/call stack size, log
verbosity, etc) are dependent on the user who is executing the
bytecode If you require low latency/immediate execution or greater
control over the execution environment, immediate execution is the
answer.

Immediate execution requires integrating the virtual machine runtime
into your program directly.  Look at [[file:vm/main.c]] to see this in
practice.

This method links your program to the =avm= runtime as well as the
=libavm= shared library, which is much greater coupling.  I would
expect this method to be used for interpreted languages, such as Lisp,
where any expression must be immediately executed.
* Related projects
[[https://github.com/aryadev-software/aal][Assembler]] program which
can compile an assembly-like language to bytecode.
* Lines of code
#+begin_src sh :results table :exports results
echo 'Files     Lines    Words    Characters'
wc -lwc $(find vm/ lib/ -regex ".*\.[ch]\(pp\)?") | awk '{print $4 "\t" $1 "\t" $2 "\t" $3}'
#+end_src

#+RESULTS:
| Files            | Lines | Words | Characters |
|------------------+-------+-------+------------|
| vm/runtime.h     |   327 |   872 |       9082 |
| vm/main.c        |   136 |   381 |       3517 |
| vm/runtime.c     |   735 |  2454 |      26742 |
| vm/struct.c      |   252 |   780 |       6805 |
| vm/struct.h      |    74 |   204 |       1564 |
| lib/inst.c       |   567 |  1369 |      14899 |
| lib/darr.h       |   149 |   709 |       4482 |
| lib/inst.h       |   277 |   547 |       5498 |
| lib/inst-macro.h |    71 |   281 |       2806 |
| lib/heap.h       |   125 |   453 |       3050 |
| lib/base.h       |   236 |   895 |       5868 |
| lib/heap.c       |    79 |   214 |       1647 |
| lib/base.c       |    82 |   288 |       2048 |
| lib/darr.c       |    76 |   219 |       1746 |
|------------------+-------+-------+------------|
| total            |  3186 |  9666 |      89754 |
